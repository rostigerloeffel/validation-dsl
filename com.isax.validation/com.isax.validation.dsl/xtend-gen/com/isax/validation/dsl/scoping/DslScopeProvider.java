/**
 * generated by Xtext
 */
package com.isax.validation.dsl.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.isax.validation.dsl.dsl.BodySentences;
import com.isax.validation.dsl.dsl.ConstraintSentence;
import com.isax.validation.dsl.dsl.DefinitionSentence;
import com.isax.validation.dsl.dsl.NodeDefinition;
import com.isax.validation.dsl.dsl.Quantification;
import com.isax.validation.dsl.dsl.QuantificationList;
import com.isax.validation.dsl.dsl.RelationQualifier;
import com.isax.validation.dsl.dsl.Sentence;
import com.isax.validation.dsl.dsl.StartOnSentence;
import com.isax.validation.dsl.dsl.TargetDefinition;
import com.isax.validation.dsl.dsl.Validator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 */
@SuppressWarnings("all")
public class DslScopeProvider extends AbstractDeclarativeScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    return super.getScope(context, reference);
  }
  
  public IScope scope_DefinitionSentence_node(final DefinitionSentence sentence, final EReference reference) {
    IScope _xblockexpression = null;
    {
      final Validator validator = EcoreUtil2.<Validator>getContainerOfType(sentence, Validator.class);
      BodySentences _body = validator.getBody();
      EList<DefinitionSentence> _definitions = _body.getDefinitions();
      final int index = _definitions.indexOf(sentence);
      BodySentences _body_1 = validator.getBody();
      EList<DefinitionSentence> _definitions_1 = _body_1.getDefinitions();
      Iterable<Pair<Integer, DefinitionSentence>> _indexed = IterableExtensions.<DefinitionSentence>indexed(_definitions_1);
      final Function1<Pair<Integer, DefinitionSentence>, Boolean> _function = (Pair<Integer, DefinitionSentence> p) -> {
        Integer _key = p.getKey();
        return Boolean.valueOf(((_key).intValue() < index));
      };
      Iterable<Pair<Integer, DefinitionSentence>> _filter = IterableExtensions.<Pair<Integer, DefinitionSentence>>filter(_indexed, _function);
      final Function1<Pair<Integer, DefinitionSentence>, DefinitionSentence> _function_1 = (Pair<Integer, DefinitionSentence> p) -> {
        return p.getValue();
      };
      Iterable<DefinitionSentence> _map = IterableExtensions.<Pair<Integer, DefinitionSentence>, DefinitionSentence>map(_filter, _function_1);
      final Function1<DefinitionSentence, Boolean> _function_2 = (DefinitionSentence d) -> {
        RelationQualifier _qualifier = d.getQualifier();
        return Boolean.valueOf((!Objects.equal(_qualifier, RelationQualifier.MUST_NOT)));
      };
      Iterable<DefinitionSentence> _filter_1 = IterableExtensions.<DefinitionSentence>filter(_map, _function_2);
      final Function1<DefinitionSentence, Boolean> _function_3 = (DefinitionSentence d) -> {
        NodeDefinition _node = d.getNode();
        return Boolean.valueOf((!Objects.equal(_node, null)));
      };
      Iterable<DefinitionSentence> _filter_2 = IterableExtensions.<DefinitionSentence>filter(_filter_1, _function_3);
      final Function1<DefinitionSentence, NodeDefinition> _function_4 = (DefinitionSentence d) -> {
        TargetDefinition _target = d.getTarget();
        return _target.getDefinition();
      };
      Iterable<NodeDefinition> _map_1 = IterableExtensions.<DefinitionSentence, NodeDefinition>map(_filter_2, _function_4);
      final Function1<NodeDefinition, Boolean> _function_5 = (NodeDefinition d) -> {
        boolean _isCollection = d.isCollection();
        return Boolean.valueOf((!_isCollection));
      };
      Iterable<NodeDefinition> _filter_3 = IterableExtensions.<NodeDefinition>filter(_map_1, _function_5);
      StartOnSentence _startOn = validator.getStartOn();
      NodeDefinition _definition = _startOn.getDefinition();
      List<NodeDefinition> _asList = Arrays.<NodeDefinition>asList(_definition);
      IScope _scopeFor = Scopes.scopeFor(_asList);
      _xblockexpression = Scopes.scopeFor(_filter_3, _scopeFor);
    }
    return _xblockexpression;
  }
  
  public IScope scope_Quantification_nodeSet(final Quantification quantification, final EReference reference) {
    IScope _xblockexpression = null;
    {
      final Validator validator = EcoreUtil2.<Validator>getContainerOfType(quantification, Validator.class);
      final DefinitionSentence sentence = EcoreUtil2.<DefinitionSentence>getContainerOfType(quantification, DefinitionSentence.class);
      BodySentences _body = validator.getBody();
      EList<DefinitionSentence> _definitions = _body.getDefinitions();
      final int index = _definitions.indexOf(sentence);
      BodySentences _body_1 = validator.getBody();
      EList<DefinitionSentence> _definitions_1 = _body_1.getDefinitions();
      final Function1<DefinitionSentence, Boolean> _function = (DefinitionSentence d) -> {
        RelationQualifier _qualifier = d.getQualifier();
        return Boolean.valueOf((!Objects.equal(_qualifier, RelationQualifier.MUST_NOT)));
      };
      Iterable<DefinitionSentence> _filter = IterableExtensions.<DefinitionSentence>filter(_definitions_1, _function);
      Iterable<Pair<Integer, DefinitionSentence>> _indexed = IterableExtensions.<DefinitionSentence>indexed(_filter);
      final Function1<Pair<Integer, DefinitionSentence>, Boolean> _function_1 = (Pair<Integer, DefinitionSentence> p) -> {
        Integer _key = p.getKey();
        return Boolean.valueOf(((_key).intValue() < index));
      };
      Iterable<Pair<Integer, DefinitionSentence>> _filter_1 = IterableExtensions.<Pair<Integer, DefinitionSentence>>filter(_indexed, _function_1);
      final Function1<Pair<Integer, DefinitionSentence>, NodeDefinition> _function_2 = (Pair<Integer, DefinitionSentence> p) -> {
        DefinitionSentence _value = p.getValue();
        TargetDefinition _target = _value.getTarget();
        return _target.getDefinition();
      };
      Iterable<NodeDefinition> _map = IterableExtensions.<Pair<Integer, DefinitionSentence>, NodeDefinition>map(_filter_1, _function_2);
      final Function1<NodeDefinition, Boolean> _function_3 = (NodeDefinition d) -> {
        return Boolean.valueOf(d.isCollection());
      };
      Iterable<NodeDefinition> _filter_2 = IterableExtensions.<NodeDefinition>filter(_map, _function_3);
      _xblockexpression = Scopes.scopeFor(_filter_2);
    }
    return _xblockexpression;
  }
  
  private ArrayList<NodeDefinition> visibleDefinitions(final EObject object) {
    ArrayList<NodeDefinition> _xblockexpression = null;
    {
      ArrayList<NodeDefinition> visible = new ArrayList<NodeDefinition>();
      Sentence current = EcoreUtil2.<Sentence>getContainerOfType(object, Sentence.class);
      while ((!Objects.equal(current, null))) {
        {
          Iterable<NodeDefinition> _parentSentenceDefinitions = this.parentSentenceDefinitions(current);
          Iterables.<NodeDefinition>addAll(visible, _parentSentenceDefinitions);
          ArrayList<NodeDefinition> _previousSiblingDefinitions = this.previousSiblingDefinitions(current);
          Iterables.<NodeDefinition>addAll(visible, _previousSiblingDefinitions);
          Sentence _xifexpression = null;
          EObject _eContainer = object.eContainer();
          boolean _notEquals = (!Objects.equal(_eContainer, null));
          if (_notEquals) {
            EObject _eContainer_1 = object.eContainer();
            _xifexpression = EcoreUtil2.<Sentence>getContainerOfType(_eContainer_1, Sentence.class);
          } else {
            _xifexpression = null;
          }
          current = _xifexpression;
        }
      }
      _xblockexpression = visible;
    }
    return _xblockexpression;
  }
  
  private ArrayList<NodeDefinition> previousSiblingDefinitions(final Sentence sentence) {
    ArrayList<NodeDefinition> _xblockexpression = null;
    {
      final BodySentences parentBody = EcoreUtil2.<BodySentences>getContainerOfType(sentence, BodySentences.class);
      EList<Sentence> _sentences = parentBody.getSentences();
      final int index = _sentences.indexOf(sentence);
      ArrayList<NodeDefinition> siblings = new ArrayList<NodeDefinition>();
      EList<Sentence> _sentences_1 = parentBody.getSentences();
      Iterable<Pair<Integer, Sentence>> _indexed = IterableExtensions.<Sentence>indexed(_sentences_1);
      final Function1<Pair<Integer, Sentence>, Boolean> _function = (Pair<Integer, Sentence> s) -> {
        Integer _key = s.getKey();
        return Boolean.valueOf(((_key).intValue() < index));
      };
      Iterable<Pair<Integer, Sentence>> _filter = IterableExtensions.<Pair<Integer, Sentence>>filter(_indexed, _function);
      Iterable<DefinitionSentence> _filter_1 = Iterables.<DefinitionSentence>filter(_filter, DefinitionSentence.class);
      final Function1<DefinitionSentence, NodeDefinition> _function_1 = (DefinitionSentence s) -> {
        TargetDefinition _target = s.getTarget();
        return _target.getDefinition();
      };
      Iterable<NodeDefinition> _map = IterableExtensions.<DefinitionSentence, NodeDefinition>map(_filter_1, _function_1);
      Iterables.<NodeDefinition>addAll(siblings, _map);
      EList<Sentence> _sentences_2 = parentBody.getSentences();
      Iterable<Pair<Integer, Sentence>> _indexed_1 = IterableExtensions.<Sentence>indexed(_sentences_2);
      final Function1<Pair<Integer, Sentence>, Boolean> _function_2 = (Pair<Integer, Sentence> s) -> {
        Integer _key = s.getKey();
        return Boolean.valueOf(((_key).intValue() < index));
      };
      Iterable<Pair<Integer, Sentence>> _filter_2 = IterableExtensions.<Pair<Integer, Sentence>>filter(_indexed_1, _function_2);
      Iterable<DefinitionSentence> _filter_3 = Iterables.<DefinitionSentence>filter(_filter_2, DefinitionSentence.class);
      final Function1<DefinitionSentence, Boolean> _function_3 = (DefinitionSentence s) -> {
        TargetDefinition _target = s.getTarget();
        NodeDefinition _local = _target.getLocal();
        return Boolean.valueOf((!Objects.equal(_local, null)));
      };
      Iterable<DefinitionSentence> _filter_4 = IterableExtensions.<DefinitionSentence>filter(_filter_3, _function_3);
      final Function1<DefinitionSentence, NodeDefinition> _function_4 = (DefinitionSentence s) -> {
        TargetDefinition _target = s.getTarget();
        return _target.getLocal();
      };
      Iterable<NodeDefinition> _map_1 = IterableExtensions.<DefinitionSentence, NodeDefinition>map(_filter_4, _function_4);
      Iterables.<NodeDefinition>addAll(siblings, _map_1);
      _xblockexpression = siblings;
    }
    return _xblockexpression;
  }
  
  private Iterable<NodeDefinition> _parentSentenceDefinitions(final ConstraintSentence sentence) {
    QuantificationList _quantifications = sentence.getQuantifications();
    EList<Quantification> _quantifications_1 = _quantifications.getQuantifications();
    final Function1<Quantification, NodeDefinition> _function = (Quantification q) -> {
      return q.getNode();
    };
    return ListExtensions.<Quantification, NodeDefinition>map(_quantifications_1, _function);
  }
  
  private Iterable<NodeDefinition> _parentSentenceDefinitions(final DefinitionSentence sentence) {
    TargetDefinition _target = sentence.getTarget();
    NodeDefinition _definition = _target.getDefinition();
    TargetDefinition _target_1 = sentence.getTarget();
    NodeDefinition _local = _target_1.getLocal();
    List<NodeDefinition> _asList = Arrays.<NodeDefinition>asList(_definition, _local);
    return IterableExtensions.<NodeDefinition>filterNull(_asList);
  }
  
  private Iterable<NodeDefinition> parentSentenceDefinitions(final Sentence sentence) {
    if (sentence instanceof ConstraintSentence) {
      return _parentSentenceDefinitions((ConstraintSentence)sentence);
    } else if (sentence instanceof DefinitionSentence) {
      return _parentSentenceDefinitions((DefinitionSentence)sentence);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(sentence).toString());
    }
  }
}
