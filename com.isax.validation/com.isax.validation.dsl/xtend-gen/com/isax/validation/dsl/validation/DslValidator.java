/**
 * generated by Xtext
 */
package com.isax.validation.dsl.validation;

import com.google.common.base.Objects;
import com.isax.validation.dsl.dsl.DefinitionSentence;
import com.isax.validation.dsl.dsl.DslPackage;
import com.isax.validation.dsl.dsl.NodeDefinition;
import com.isax.validation.dsl.dsl.Quantification;
import com.isax.validation.dsl.validation.AbstractDslValidator;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;

@SuppressWarnings("all")
public class DslValidator extends AbstractDslValidator {
  @Check
  public void refersSet(final Quantification quantification) {
    NodeDefinition _nodeSet = quantification.getNodeSet();
    boolean _isCollection = _nodeSet.isCollection();
    boolean _not = (!_isCollection);
    if (_not) {
      NodeDefinition _nodeSet_1 = quantification.getNodeSet();
      String _name = _nodeSet_1.getName();
      String _plus = ("Quantification node set (" + _name);
      String _plus_1 = (_plus + ") is not a set!");
      EReference _quantification_NodeSet = DslPackage.eINSTANCE.getQuantification_NodeSet();
      this.error(_plus_1, quantification, _quantification_NodeSet);
    }
  }
  
  @Check
  public void refersNode(final DefinitionSentence sentence) {
    boolean _and = false;
    Quantification _quantification = sentence.getQuantification();
    boolean _equals = Objects.equal(_quantification, null);
    if (!_equals) {
      _and = false;
    } else {
      NodeDefinition _node = sentence.getNode();
      boolean _isCollection = _node.isCollection();
      _and = _isCollection;
    }
    if (_and) {
      EReference _definitionSentence_Node = DslPackage.eINSTANCE.getDefinitionSentence_Node();
      this.error("Use \'each\' or \'any\' to obtain neighbouring nodes of node sets!", sentence, _definitionSentence_Node);
    }
  }
}
