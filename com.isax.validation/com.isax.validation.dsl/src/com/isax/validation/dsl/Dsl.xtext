grammar com.isax.validation.dsl.Dsl with org.eclipse.xtext.common.Terminals

generate dsl "http://www.isax.com/validation/dsl/Dsl"

Validator:
	sentences+=Sentence+;


Sentence:
	StartOnSentence | DefinitionSentence | ConstraintSentence | PredicateDefinitionSentence;

StartOnSentence:
	'start on' definition=NodeDefinition;

DefinitionSentence:
	(quantification=Quantification | node=[NodeDefinition]) 
	qualifier=RelationQualifier
	target=TargetDefinition;

ConstraintSentence:
	'for'
	quantifications=QuantificationList? 
	nodes=NodeReferenceList? 
	('holds that' | ':')
	predicate=PredicateExpression;

PredicateDefinitionSentence:
	'define' name=ID parameters=ParameterList? ('as' | ':') predicate=PredicateExpression;


NodeDefinition:
	name=ID collection?='*'? selectors=SelectorList?;
	
NodeReferenceList:
	nodes+=[NodeDefinition] (',' nodes+=[NodeDefinition])*;


TargetDefinition:
	axis=Axis definition=NodeDefinition ('where holds' '{' predicate=PredicateExpression '}')? ('with property' '{' assignments=AssignmentList '}')?;


SelectorList:
	('being' selectors=SelectorListDef) | ('(' selectors=SelectorListDef ')');

SelectorListDef:
	selectors+=Selector ('or' selectors+=Selector)*;

Selector:
	type=ID;


PredicateExpression:
	AndExpression;

AndExpression returns PredicateExpression:
	OrExpression ({AndExpression.lhs=current} ('and' | ',') rhs=OrExpression)*;

OrExpression returns PredicateExpression:
	ImpliesExpression ({OrExpression.lhs=current} 'or' rhs=ImpliesExpression)*;

ImpliesExpression returns PredicateExpression:
	lhs=PrimaryExpression ({ImpliesExpression.lhs=current} ('implies' | '=>') rhs=PrimaryExpression)?;

PrimaryExpression returns PredicateExpression:
	(negated?='not')? (call=PredicateCall | ('(' inner=PredicateExpression ')'));

PredicateCall:
	(PropertyRelationPredicate | DefinitionSentencePredicate | PredicateReference) ('[' label=ID ']')?;
	
PropertyRelationPredicate:
	lhs=PropertyExpression relation=PropertyRelation rhs=PropertyExpression;

DefinitionSentencePredicate:
	sentence=DefinitionSentence;

// Don't handle function-like calls manually, use Xbase instead
PredicateReference:
	reference=[PredicateDefinitionSentence]
	arguments=ArgumentList;


Parameter:
	node=NodeDefinition;
	
ParameterList:
	parameters+=Parameter (',' parameters+=Parameter)*;

Argument:
	node=[NodeDefinition];

ArgumentList:
	arguments+=Argument (',' arguments+=Argument)*;


Assignment:
	reference=PropertyReferenceExpression ('becomes' | ':=') expression=PropertyExpression;

AssignmentList:
	assignments+=Assignment (',' assignments+=Assignment)*;


Quantification:
	quantor=Quantor node=NodeDefinition 'in' nodeSet=[NodeDefinition];

QuantificationList:
	quantifications+=Quantification (',' quantifications+=Quantification)*;


PropertyExpression:
	PropertyValueExpression | PropertyReferenceExpression;
	
PropertyValueExpression:
	'v' value=STRING;

PropertyReferenceExpression:
	'n' node=[NodeDefinition] '.' Property=ID;

enum Quantor:
	Each='each' | Any='any';

enum RelationQualifier:
	Must='must have' | MustNot='must not have' | Can='can have';
	
enum Axis:
	Parent='parent' | Child='child' | Ancestor='ancestor' | Descendant='descendant' |
	Parents='multiple parents' | Children='multiple children' | Ancestors='multiple ancestors' | Descendants='multiple descendants';
	
enum PropertyRelation:
	Equals='equals' | NotEquals='not equals' | Greater='greater than' | Lesser='lesser than' | GreaterEquals='greater or equals than' | LesserEquals='lesser or equals than';
	