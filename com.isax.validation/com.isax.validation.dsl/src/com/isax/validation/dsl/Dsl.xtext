grammar com.isax.validation.dsl.Dsl with org.eclipse.xtext.xbase.Xbase

import "http://www.isax.com/validation/dsl/Dsl"

import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

Validator:
	startOn = StartOnSentence
	body = BodySentences
	predicates += PredicateDefinitionSentence*;
	
BodySentences:
	{BodySentences}
	(definitions += DefinitionSentence | constraints += ConstraintSentence)*;

Sentence:
	StartOnSentence | DefinitionSentence | ConstraintSentence | PredicateDefinitionSentence;

StartOnSentence:
	'start on' definition=NodeDefinition;

DefinitionSentence:
	(quantification=Quantification | node=[NodeDefinition]) 
	qualifier=RelationQualifier
	target=TargetDefinition;

ConstraintSentence:
	'for'
	quantifications=QuantificationList? 
	nodes=NodeReferenceList? 
	'holds' '{'
	predicate=PredicateExpression
	'}';

PredicateDefinitionSentence:
	'define' name=ID parameters=ParameterList? 'as' '{' body = BodySentences '}';


NodeDefinition:
	name=ID collection?='*'? selectors=SelectorList?;
	
NodeReferenceList:
	nodes+=[NodeDefinition] (',' nodes+=[NodeDefinition])*;


TargetDefinition:
	axis=Axis (local=NodeDefinition ':')? definition=NodeDefinition ('where' '{' body=BodySentences '}')? ('then' '{' assignments=AssignmentList '}')? ;


SelectorList:
	('being' selectors=SelectorListDef) | ('(' selectors=SelectorListDef ')');

SelectorListDef:
	selectors+=Selector ('or' selectors+=Selector)*;

Selector:
	type=ID;


PredicateExpression:
	AndExpression;

AndExpression returns PredicateExpression:
	OrExpression ({AndExpression.lhs=current} ('and' | ',') rhs=OrExpression)*;

OrExpression returns PredicateExpression:
	ImpliesExpression ({OrExpression.lhs=current} 'or' rhs=ImpliesExpression)*;

ImpliesExpression returns PredicateExpression:
	lhs=PrimaryExpression ({ImpliesExpression.lhs=current} ('implies' | '=>') rhs=PrimaryExpression)?;

PrimaryExpression returns PredicateExpression:
	(negated?='not')? (call=PredicateCall | ('(' inner=PredicateExpression ')'));

PredicateCall:
	(PropertyRelationPredicate | DefinitionSentencePredicate | PredicateReference | PredicateXExpression) ('[' label=ID ']')?;
	
PredicateXExpression:
	expression = XBlockExpression;	
	
PropertyRelationPredicate:
	lhs=PropertyExpression relation=PropertyRelation rhs=PropertyExpression;

DefinitionSentencePredicate:
	sentence=DefinitionSentence;

PredicateReference:
	reference=[PredicateDefinitionSentence]
	arguments=ArgumentList;


Parameter:
	node=NodeDefinition;
	
ParameterList:
	parameters+=Parameter (',' parameters+=Parameter)*;

Argument:
	node=[NodeDefinition];

ArgumentList:
	arguments+=Argument (',' arguments+=Argument)*;


Assignment:
	reference=PropertyReferenceExpression ('becomes' | ':=') expression=AssignmentExpression;

AssignmentList:
	assignments+=Assignment (',' assignments+=Assignment)*;

AssignmentExpression:
	PropertyExpression | AssignmentXExpression;
	
AssignmentXExpression:
	expression = XBlockExpression;

Quantification:
	quantor=Quantor node=NodeDefinition 'in' nodeSet=[NodeDefinition];

QuantificationList:
	quantifications+=Quantification (',' quantifications+=Quantification)*;


PropertyExpression:
	PropertyValueExpression | PropertyReferenceExpression;
	
PropertyValueExpression:
	value=STRING;

PropertyReferenceExpression:
	node=[NodeDefinition] '.' Property=ID;

enum Quantor:
	Each='each' | Any='any';

enum RelationQualifier:
	Must='must have' | MustNot='must not have' | Can='can have';
	
enum Axis:
	Parent='parent' | Child='child' | Ancestor='ancestor' | Descendant='descendant' |
	Parents='multiple parents' | Children='multiple children' | Ancestors='multiple ancestors' | Descendants='multiple descendants';
	
enum PropertyRelation:
	Equals='equals' | NotEquals='not equals' | Greater='greater than' | Lesser='lesser than' | GreaterEquals='greater or equals than' | LesserEquals='lesser or equals than';
	