/*
 * generated by Xtext
 */
package com.isax.validation.dsl.scoping

import com.isax.validation.dsl.dsl.BodySentences
import com.isax.validation.dsl.dsl.ConstraintSentence
import com.isax.validation.dsl.dsl.DefinitionSentence
import com.isax.validation.dsl.dsl.NodeDefinition
import com.isax.validation.dsl.dsl.PredicateReference
import com.isax.validation.dsl.dsl.PropertyReferenceExpression
import com.isax.validation.dsl.dsl.Quantification
import com.isax.validation.dsl.dsl.Sentence
import com.isax.validation.dsl.dsl.StartOnSentence
import com.isax.validation.dsl.dsl.Validator
import java.util.ArrayList
import java.util.Arrays
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType
import org.eclipse.xtext.xbase.lib.Functions.Function1

class DslScopeProvider extends AbstractDeclarativeScopeProvider {
	
	def scope_Quantification_nodeSet(Quantification quantification, EReference reference) {
		quantification.visibleDefinitions [d|d.collection]
	}
	
	def scope_Argument_node(PredicateReference predicate, EReference reference) {
		predicate.visibleDefinitions [d|!d.collection]
	}
	
	def scope_DefinitionSentence_node(DefinitionSentence sentence, EReference reference) {
		sentence.visibleDefinitions [d|!d.collection]
	}
	
	def scope_PropertyReferenceExpression_node(PropertyReferenceExpression expression, EReference reference) {
		expression.visibleDefinitions [d|!d.collection]
	}

	private def visibleDefinitions(EObject object, Function1<? super NodeDefinition, Boolean> predicate) {
		scopeForSentence(object.getContainerOfType(Sentence), predicate)
	}
	
	private def dispatch IScope scopeForSentence(StartOnSentence startOn, Function1<? super NodeDefinition, Boolean> predicate) {
		Scopes.scopeFor(Arrays.asList(startOn.definition).filter(predicate))
	}
	
	private def dispatch IScope scopeForSentence(Sentence sentence, Function1<? super NodeDefinition, Boolean> predicate) {
		if (sentence == null) return IScope.NULLSCOPE
		
		var visible = new ArrayList<NodeDefinition>()
		visible += sentenceDefinitions(sentence)
		visible += previousSiblingDefinitions(sentence)
		
		val parentSentence = sentence.eContainer.getContainerOfType(Sentence) ?: sentence.eContainer.getContainerOfType(Validator)?.startOn
		Scopes.scopeFor(visible.filter(predicate), scopeForSentence(parentSentence, predicate))
	}
	
	private def previousSiblingDefinitions(Sentence sentence) {
		val parentBody = sentence.getContainerOfType(BodySentences)
		val index = parentBody.sentences.indexOf(sentence)
		var siblings = new ArrayList<NodeDefinition>()
		siblings += parentBody.sentences.indexed
				.filter[s|s.key < index].map[s|s.value]
				.filter(DefinitionSentence).map[s|s.target.definition]
		siblings += parentBody.sentences.indexed
				.filter[s|s.key < index].map[s|s.value]
				.filter(DefinitionSentence)
				.filter[s|s.target.local != null].map[s|s.target.local]
		siblings
	}
	
	private def dispatch sentenceDefinitions(ConstraintSentence sentence) {
		sentence.quantifications.quantifications.map[q|q.node]
	}
	
	private def dispatch sentenceDefinitions(DefinitionSentence sentence) {
		Arrays.asList(sentence.quantification?.node, sentence.target?.definition, sentence.target?.local).filterNull
	}
}