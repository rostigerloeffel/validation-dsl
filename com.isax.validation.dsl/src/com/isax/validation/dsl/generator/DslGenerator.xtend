/*
 * generated by Xtext
 */
package com.isax.validation.dsl.generator

import com.google.inject.Guice
import com.google.inject.Injector
import com.isax.validation.dsl.DslRuntimeModule
import com.isax.validation.dsl.dsl.Argument
import com.isax.validation.dsl.dsl.ArgumentList
import com.isax.validation.dsl.dsl.Axis
import com.isax.validation.dsl.dsl.ConstraintSentence
import com.isax.validation.dsl.dsl.DefinitionSentence
import com.isax.validation.dsl.dsl.DefinitionSentencePredicate
import com.isax.validation.dsl.dsl.NodeDefinition
import com.isax.validation.dsl.dsl.Parameter
import com.isax.validation.dsl.dsl.ParameterList
import com.isax.validation.dsl.dsl.PredicateDefinitionSentence
import com.isax.validation.dsl.dsl.PredicateExpression
import com.isax.validation.dsl.dsl.PredicateReference
import com.isax.validation.dsl.dsl.PropertyRelationPredicate
import com.isax.validation.dsl.dsl.Quantor
import com.isax.validation.dsl.dsl.RelationQualifier
import com.isax.validation.dsl.dsl.Selector
import com.isax.validation.dsl.dsl.SelectorList
import com.isax.validation.dsl.dsl.StartOnSentence
import com.isax.validation.dsl.dsl.Validator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.parser.antlr.splitting.simpleExpressions.NotExpression
import org.eclipse.xtext.serializer.ISerializer

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class DslGenerator implements IGenerator {
	
	private static final Injector injector = Guice.createInjector(new  DslRuntimeModule());  
	private static final ISerializer serializer = injector.getInstance(ISerializer);
		
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val validatorName = resource.URI.segmentsList.last.split('\\.').head
		fsa.generateFile(validatorName + '.java', generateValidator(validatorName, resource.contents.head as Validator))
	}
	
	def generateValidator(String validatorName, Validator validator) '''
		class «validatorName» {
			public boolean validate(Node node) {
				«FOR sentence : validator.sentences»
					«IF !(sentence instanceof PredicateDefinitionSentence)»
«««						// «serializer.serialize(sentence).trim.replaceAll("\\n", "")»
						«sentenceStatements(sentence)»
						
					«ENDIF»
				«ENDFOR»
			}
			
			«FOR sentence : validator.sentences»
				«IF sentence instanceof PredicateDefinitionSentence»
«««					// «serializer.serialize(sentence).trim.replaceAll("\\n", "")»
					«sentenceStatements(sentence)»
					
				«ENDIF»
			«ENDFOR»
		}
	'''
	
	def dispatch sentenceStatements(StartOnSentence sentence) '''
		Node «sentence.definition.name» = element;
		if («sentence.definition.name» == null || !hasType(«sentence.definition.name», «selectorExpression(sentence.definition.selectors)»)) {
			return true;
		}
	'''
	
	def dispatch sentenceStatements(DefinitionSentence sentence) '''
		«IF sentence.node != null»
			«singleNodeDefinition(sentence)»
		«ENDIF»
		«IF sentence.quantification != null»
			«quantifiedDefinition(sentence)»
		«ENDIF»
	'''
	
	def dispatch sentenceStatements(ConstraintSentence sentence) '''
	'''
	
	def dispatch sentenceStatements(PredicateDefinitionSentence sentence) '''
		private boolean «sentence.name»(«parameterList(sentence.parameters)») {
			return true;
		}
	'''
	
	def singleNodeDefinition(DefinitionSentence sentence) '''
		«nodeAssignmentStatement(sentence.target.definition, sentence.target.axis, sentence.node, sentence.target.definition.selectors, sentence.target.predicate)»
		{
			boolean satisfied = «sentence.target.definition.name» «qualifierSatisfiedAssignment(sentence.getTarget.definition, sentence.qualifier)»;
			if (!satisfied) return satisfied;
		}
	'''
	
	def quantifiedDefinition(DefinitionSentence sentence) '''
		{
			boolean satisfied = «initialQualifierSatisfaction(sentence.qualifier)»;
			for («sentence.quantification.node.name» : «sentence.quantification.nodeSet.name») {
				«nodeAssignmentStatement(sentence.getTarget.definition, sentence.getTarget.axis, sentence.quantification.node, sentence.target.definition.selectors, sentence.target.predicate)»
				satisfied «quantorSatisfactionRelation(sentence.quantification.quantor)» «qualifierSatisfiedAssignment(sentence.getTarget.definition, sentence.qualifier)»;
			}
			
			if (!satisfied) return satisfied;
		}
	'''
	
	def nodeAssignmentStatement(NodeDefinition assignee, Axis axis, NodeDefinition source, SelectorList types, PredicateExpression predicate) '''
		Node «assignee.name» = «axis.getName().toLowerCase»(«source.name», «selectorExpression(types)», (WElement element) -> {
			«IF predicate == null»
				return true;
			«ELSE»
				«predicateExpression(predicate)»
			«ENDIF»
		});
	'''
	
	def qualifierSatisfiedAssignment(NodeDefinition node, RelationQualifier qualifier) {
		switch (qualifier) {
			case CAN: return "true"
			case MUST: return "!= null"
			case MUST_NOT: return "== null"
		}
	}
	
	def initialQualifierSatisfaction(RelationQualifier qualifier) {
		switch (qualifier) {
			case CAN: return "true"
			case MUST: return "true"
			case MUST_NOT: return "false"
		}
	}
	
	def quantorSatisfactionRelation(Quantor quantor) {
		switch (quantor) {
			case ANY: return "|="
			case EACH: return "&="
		}
	}
	
	def selectorExpression(SelectorList list) {
		if (list != null && list.selectors != null) {
			return list.selectors.selectors.join('_', [Selector s | s.type.toUpperCase()]) + '_TYPES'
		} else {
			return ""
		}
	}
	
	def dispatch predicateExpression(PredicateExpression expression) {
		//'!' + predicateExpression(expression.inner)
	}
	
	def dispatch predicateExpression(PropertyRelationPredicate predicate) '''
		PredicateUtil.«predicate.relation.getName().toFirstLower»(«predicate.lhs», «predicate.rhs»);
	'''

	def dispatch predicateExpression(DefinitionSentencePredicate predicate) '''
	'''
	
	def dispatch predicateExpression(PredicateReference reference) '''
		«reference.reference.name»(«argumentList(reference.arguments)»);
	'''
	
	def argumentList(ArgumentList list) {
		if (list != null) list.arguments.join(", ", [Argument argument | argument.node.name])
	}
	
	def parameterList(ParameterList list) {
		if (list != null) list.parameters.join(", ", [Parameter parameter | if (parameter.node.isCollection) "Collection<Node>" else "Node" + " " + parameter.node.name])
	}
}
